<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>第一篇文章 | 胡说</title>
<meta name=keywords content>
<meta name=description content="一、基本介绍 1，什么是 Disruptor?  Disruptor 是英国外汇交易公司 LMAX 开发的一个高性能的并发框架。可以认为是线程间通信的高效低延时的内存消息组件，它最大的特点是高性能。与 Kafka、RabbitMQ 用于服务间的消息队列不同，disruptor 一般用于一个 JVM 中多个线程间消息的传递。 从功能上来看，Disruptor 实现了“队列”的功能，而且是一个有界队列（事实上它是一个无锁的线程间通信库）。作用与 ArrayBlockingQueue 有相似之处，但是disruptor 从功能、性能上又都远好于 ArrayBlockingQueue。  实际上这个框架在 log4j，以及 activeMQ 源码扩展中都有使用。(例如：由于采用了 Disruptor，Log4j 2 性能明显优于 Log4j 1.x，Logback 和 java.util.logging，尤其是在多线程应用程序中，异步记录器的吞吐量比 Log4j 1.x 和 Logback 高 18 倍，延迟低。)
2，Disruptor 的优势 （1）Disruptor 最直接的应用场景自然就是“生产者-消费者”模型的应用场合了，虽然这些我们使用 JDK 的 BlockingQueue 也能做到（我之前也写过相关文章：点击查看），但 Disruptor 的性能比 BlockingQueue 提高了 5~10 倍左右：
下图是官方对 disruptor 和 ArrayBlockingQueue 的性能在不同的应用场景下做了对比，数据中 P 代表 producer，C 代表 consumer，ABS 代表 ArrayBlockingQueue。
（2）也就是说 BlockingQueue 能做的，Disruptor 都能做到且做的更好。同时 Disruptor 还能做得更多：">
<meta name=author content="zhangyw">
<link rel=canonical href=https://zhangyingwei.github.io/posts/first-page/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.ac77af2d98cda218063666045248672284bb2cc70874685dbc471ba07cf9d667.css integrity="sha256-rHevLZjNohgGNmYEUkhnIoS7LMcIdGhdvEcboHz51mc=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://zhangyingwei.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://zhangyingwei.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://zhangyingwei.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://zhangyingwei.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://zhangyingwei.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="第一篇文章">
<meta property="og:description" content="一、基本介绍 1，什么是 Disruptor?  Disruptor 是英国外汇交易公司 LMAX 开发的一个高性能的并发框架。可以认为是线程间通信的高效低延时的内存消息组件，它最大的特点是高性能。与 Kafka、RabbitMQ 用于服务间的消息队列不同，disruptor 一般用于一个 JVM 中多个线程间消息的传递。 从功能上来看，Disruptor 实现了“队列”的功能，而且是一个有界队列（事实上它是一个无锁的线程间通信库）。作用与 ArrayBlockingQueue 有相似之处，但是disruptor 从功能、性能上又都远好于 ArrayBlockingQueue。  实际上这个框架在 log4j，以及 activeMQ 源码扩展中都有使用。(例如：由于采用了 Disruptor，Log4j 2 性能明显优于 Log4j 1.x，Logback 和 java.util.logging，尤其是在多线程应用程序中，异步记录器的吞吐量比 Log4j 1.x 和 Logback 高 18 倍，延迟低。)
2，Disruptor 的优势 （1）Disruptor 最直接的应用场景自然就是“生产者-消费者”模型的应用场合了，虽然这些我们使用 JDK 的 BlockingQueue 也能做到（我之前也写过相关文章：点击查看），但 Disruptor 的性能比 BlockingQueue 提高了 5~10 倍左右：
下图是官方对 disruptor 和 ArrayBlockingQueue 的性能在不同的应用场景下做了对比，数据中 P 代表 producer，C 代表 consumer，ABS 代表 ArrayBlockingQueue。
（2）也就是说 BlockingQueue 能做的，Disruptor 都能做到且做的更好。同时 Disruptor 还能做得更多：">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zhangyingwei.github.io/posts/first-page/"><meta property="og:image" content="https://zhangyingwei.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-04-09T21:27:00+08:00">
<meta property="article:modified_time" content="2022-04-09T21:27:00+08:00"><meta property="og:site_name" content="胡说">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://zhangyingwei.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name=twitter:title content="第一篇文章">
<meta name=twitter:description content="一、基本介绍 1，什么是 Disruptor?  Disruptor 是英国外汇交易公司 LMAX 开发的一个高性能的并发框架。可以认为是线程间通信的高效低延时的内存消息组件，它最大的特点是高性能。与 Kafka、RabbitMQ 用于服务间的消息队列不同，disruptor 一般用于一个 JVM 中多个线程间消息的传递。 从功能上来看，Disruptor 实现了“队列”的功能，而且是一个有界队列（事实上它是一个无锁的线程间通信库）。作用与 ArrayBlockingQueue 有相似之处，但是disruptor 从功能、性能上又都远好于 ArrayBlockingQueue。  实际上这个框架在 log4j，以及 activeMQ 源码扩展中都有使用。(例如：由于采用了 Disruptor，Log4j 2 性能明显优于 Log4j 1.x，Logback 和 java.util.logging，尤其是在多线程应用程序中，异步记录器的吞吐量比 Log4j 1.x 和 Logback 高 18 倍，延迟低。)
2，Disruptor 的优势 （1）Disruptor 最直接的应用场景自然就是“生产者-消费者”模型的应用场合了，虽然这些我们使用 JDK 的 BlockingQueue 也能做到（我之前也写过相关文章：点击查看），但 Disruptor 的性能比 BlockingQueue 提高了 5~10 倍左右：
下图是官方对 disruptor 和 ArrayBlockingQueue 的性能在不同的应用场景下做了对比，数据中 P 代表 producer，C 代表 consumer，ABS 代表 ArrayBlockingQueue。
（2）也就是说 BlockingQueue 能做的，Disruptor 都能做到且做的更好。同时 Disruptor 还能做得更多：">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zhangyingwei.github.io/posts/"},{"@type":"ListItem","position":2,"name":"第一篇文章","item":"https://zhangyingwei.github.io/posts/first-page/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"第一篇文章","name":"第一篇文章","description":"一、基本介绍 1，什么是 Disruptor?  Disruptor 是英国外汇交易公司 LMAX 开发的一个高性能的并发框架。可以认为是线程间通信的高效低延时的内存消息组件，它最大的特点是高性能。与 Kafka、RabbitMQ 用于服务间的消息队列不同，disruptor 一般用于一个 JVM 中多个线程间消息的传递。 从功能上来看，Disruptor 实现了“队列”的功能，而且是一个有界队列（事实上它是一个无锁的线程间通信库）。作用与 ArrayBlockingQueue 有相似之处，但是disruptor 从功能、性能上又都远好于 ArrayBlockingQueue。  实际上这个框架在 log4j，以及 activeMQ 源码扩展中都有使用。(例如：由于采用了 Disruptor，Log4j 2 性能明显优于 Log4j 1.x，Logback 和 java.util.logging，尤其是在多线程应用程序中，异步记录器的吞吐量比 Log4j 1.x 和 Logback 高 18 倍，延迟低。)\n2，Disruptor 的优势 （1）Disruptor 最直接的应用场景自然就是“生产者-消费者”模型的应用场合了，虽然这些我们使用 JDK 的 BlockingQueue 也能做到（我之前也写过相关文章：点击查看），但 Disruptor 的性能比 BlockingQueue 提高了 5~10 倍左右：\n下图是官方对 disruptor 和 ArrayBlockingQueue 的性能在不同的应用场景下做了对比，数据中 P 代表 producer，C 代表 consumer，ABS 代表 ArrayBlockingQueue。\n（2）也就是说 BlockingQueue 能做的，Disruptor 都能做到且做的更好。同时 Disruptor 还能做得更多：","keywords":[],"articleBody":"一、基本介绍 1，什么是 Disruptor?  Disruptor 是英国外汇交易公司 LMAX 开发的一个高性能的并发框架。可以认为是线程间通信的高效低延时的内存消息组件，它最大的特点是高性能。与 Kafka、RabbitMQ 用于服务间的消息队列不同，disruptor 一般用于一个 JVM 中多个线程间消息的传递。 从功能上来看，Disruptor 实现了“队列”的功能，而且是一个有界队列（事实上它是一个无锁的线程间通信库）。作用与 ArrayBlockingQueue 有相似之处，但是disruptor 从功能、性能上又都远好于 ArrayBlockingQueue。  实际上这个框架在 log4j，以及 activeMQ 源码扩展中都有使用。(例如：由于采用了 Disruptor，Log4j 2 性能明显优于 Log4j 1.x，Logback 和 java.util.logging，尤其是在多线程应用程序中，异步记录器的吞吐量比 Log4j 1.x 和 Logback 高 18 倍，延迟低。)\n2，Disruptor 的优势 （1）Disruptor 最直接的应用场景自然就是“生产者-消费者”模型的应用场合了，虽然这些我们使用 JDK 的 BlockingQueue 也能做到（我之前也写过相关文章：点击查看），但 Disruptor 的性能比 BlockingQueue 提高了 5~10 倍左右：\n下图是官方对 disruptor 和 ArrayBlockingQueue 的性能在不同的应用场景下做了对比，数据中 P 代表 producer，C 代表 consumer，ABS 代表 ArrayBlockingQueue。\n（2）也就是说 BlockingQueue 能做的，Disruptor 都能做到且做的更好。同时 Disruptor 还能做得更多：\n 同一个“事件”可以有多个消费者，消费者之间既可以并行处理，也可以相互依赖形成处理的先后次序（形成一个依赖图）； 预分配用于存储事件内容的内存空间； 针对极高的性能目标而实现的极度优化和无锁的设计；  3，Disruptor 性能高效的原因 二、基本用法 1，添加依赖 SpringBoot 项目如果要与 Disruptor 进行整合十分简单，只要在 pom 文件中引入 disruptor 依赖即可：\n com.lmax disruptor 3.4.2  2，创建一些工具类 我们首先封装一些对于 disruptor 使用的工具类，用于简化开发并约束开发规范。\n/*事件对象*/ public class ObjectEventT { private T obj; public ObjectEvent() { } public T getObj() { return this.obj; } public void setObj(T obj) { this.obj = obj; } } （2）需要让 Disruptor 为我们创建事件，我们同时还声明了一个 EventFactory 来实例化 Event 对象：\n提示：Disruptor 通过 EventFactory 在 RingBuffer 中预创建 Event 的实例。一个 Event 实例实际上被用作一个“数据槽”，发布者发布前，先从 RingBuffer 获得一个 Event 的实例，然后往 Event 实例中填充数据，之后再发布到 RingBuffer 中，之后由 Consumer 获得该 Event 实例并从中读取数据。\n/*事件生成工厂（用来初始化预分配事件对象）*/ public class ObjectEventFactoryT implements EventFactoryObjectEventT { public ObjectEventFactory() { } public ObjectEventT newInstance() { return new ObjectEvent(); } } （3）接着定义一个消费者抽象类，后面我们所有自定义的消费者都需要继承这个抽象类，并实现 consume 方法（对获取的数据进行业务处理）：\n/*消费者抽象类*/ public abstract class ADisruptorConsumer implements EventHandler, WorkHandler { public ADisruptorConsumer() { } public void onEvent(ObjectEvent event, long sequence, boolean endOfBatch) throws Exception { this.onEvent(event); } public void onEvent(ObjectEvent event) throws Exception { this.consume(event.getObj()); } public abstract void consume(T var1); } （4）接着创建一个 Disruptor 队列操作工具类 DisruptorQueue，用于初始化 disruptor 以及 ringBuffer 对象，并封装类一些常用的方法：\n/*Disruptor队列操作工具类*/ public class DisruptorQueue { private Disruptor disruptor; private RingBuffer ringBuffer; public DisruptorQueue(Disruptor disruptor) { this.disruptor = disruptor; this.ringBuffer = disruptor.getRingBuffer(); this.disruptor.start(); } public void add(T t) { if (t != null) { long sequence = this.ringBuffer.next(); try { ObjectEvent event = (ObjectEvent)this.ringBuffer.get(sequence); event.setObj(t); } finally { this.ringBuffer.publish(sequence); } } } public void addAll(List ts) { if (ts != null) { Iterator var2 = ts.iterator(); while(var2.hasNext()) { T t = var2.next(); if (t != null) { this.add(t); } } } } public long cursor() { return this.disruptor.getRingBuffer().getCursor(); } public void shutdown() { this.disruptor.shutdown(); } public Disruptor getDisruptor() { return this.disruptor; } public void setDisruptor(Disruptor disruptor) { this.disruptor = disruptor; } public RingBuffer getRingBuffer() { return this.ringBuffer; } public void setRingBuffer(RingBuffer ringBuffer) { this.ringBuffer = ringBuffer; } } （5）最后创建一个 DisruptorQueue 工程类，用于生成上面定义的 DisruptorQueue 对象，并且支持“点对点”以及“发布订阅”这两种模式：\nDisruptor 提供了多个 WaitStrategy（等待策略）的实现，每种策略都具有不同性能和优缺点，根据实际运行环境的 CPU 的硬件特点选择恰当的策略，并配合特定的 JVM 的配置参数，能够实现不同的性能提升：\n BlockingWaitStrategy 是最低效的策略，但其对 CPU 的消耗最小并且在各种不同部署环境中能提供更加一致的性能表现； SleepingWaitStrategy 的性能表现跟 BlockingWaitStrategy 差不多，对 CPU 的消耗也类似，但其对生产者线程的影响最小，适合用于异步日志类似的场景； YieldingWaitStrategy 的性能是最好的，适合用于低延迟的系统。在要求极高性能且事件处理线数小于 CPU 逻辑核心数的场景中，推荐使用此策略；例如：CPU 开启超线程的特性。  /*Disruptor队列操作工具类工厂*/ public class DisruptorQueueFactory { public DisruptorQueueFactory() { } // 创建\"点对电模式\"的操作队列，即同一事件会被一组消费者其中之一消费 public static  DisruptorQueue getWorkPoolQueue(int queueSize, boolean isMoreProducer, ADisruptorConsumer... consumers) { Disruptor _disruptor = new Disruptor(new ObjectEventFactory(), queueSize, Executors.defaultThreadFactory(), isMoreProducer ? ProducerType.MULTI : ProducerType.SINGLE, new SleepingWaitStrategy()); _disruptor.handleEventsWithWorkerPool(consumers); return new DisruptorQueue(_disruptor); } // 创建\"发布订阅模式\"的操作队列，即同一事件会被多个消费者并行消费 public static  DisruptorQueue getHandleEventsQueue(int queueSize, boolean isMoreProducer, ADisruptorConsumer... consumers) { Disruptor _disruptor = new Disruptor(new ObjectEventFactory(), queueSize, Executors.defaultThreadFactory(), isMoreProducer ? ProducerType.MULTI : ProducerType.SINGLE, new SleepingWaitStrategy()); _disruptor.handleEventsWith(consumers); return new DisruptorQueue(_disruptor); } // 直接通过传入的 Disruptor 对象创建操作队列（如果消费者有依赖关系的话可以用此方法） public static  DisruptorQueue getQueue(Disruptor disruptor) { return new DisruptorQueue(disruptor); } } 3，使用样例 （1）首先我们创建一个生产者，代码如下。我们使用 disruptorQueue 对象的 add() 方法插入元素，当队列未满时，该方法会直接插入没有返回值；队列满时会阻塞等待，一直等到队列未满时再插入。\npublic class MyProducerThread implements Runnable { private String name; private DisruptorQueue disruptorQueue; private volatile boolean flag = true; private static AtomicInteger count = new AtomicInteger(); public MyProducerThread(String name, DisruptorQueue disruptorQueue) { this.name = name; this.disruptorQueue = disruptorQueue; } @Override public void run() { try { System.out.println(now() + this.name + \"：线程启动。\"); while (flag) { String data = count.incrementAndGet()+\"\"; // 将数据存入队列中 disruptorQueue.add(data); System.out.println(now() + this.name + \"：存入\" + data + \"到队列中。\"); } } catch (Exception e) { } finally { System.out.println(now() + this.name + \"：退出线程。\"); } } public void stopThread() { this.flag = false; } // 获取当前时间（分:秒） public String now() { Calendar now = Calendar.getInstance(); return \"[\" + now.get(Calendar.MINUTE) + \":\" + now.get(Calendar.SECOND) + \"] \"; } } （2）接着创建一个消费者，每次获取到元素之后会等待个 1 秒钟，模拟实际业务处理耗时，也便于观察队列情况。\npublic class MyConsumer extends ADisruptorConsumer { private String name; public MyConsumer(String name) { this.name = name; } public void consume(String data) { System.out.println(now() + this.name + \"：拿到队列中的数据：\" + data); //等待1秒钟 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } // 获取当前时间（分:秒） public String now() { Calendar now = Calendar.getInstance(); return \"[\" + now.get(Calendar.MINUTE) + \":\" + now.get(Calendar.SECOND) + \"] \"; } } （3）最后分别创建一个生产者以及一个消费者进行测试，并且 3 秒种之后通知生产者线程退出。\n注意：RingBuffer 大小（即队列大小）必须是 2 的 N 次方，实际项目中我们通常将其设置为 1024 * 1024。\npublic class DisruptorTest { public static void main(String[] args) throws InterruptedException { // 创建一个消费者 MyConsumer myConsumer = new MyConsumer(\"----消费者1\"); // 创建一个Disruptor队列操作类对象（RingBuffer大小为4，false表示只有一个生产者） DisruptorQueue disruptorQueue = DisruptorQueueFactory.getHandleEventsQueue(4, false, myConsumer); // 创建一个生产者，开始模拟生产数据 MyProducerThread myProducerThread = new MyProducerThread(\"11111生产者1\", disruptorQueue); Thread t1 = new Thread(myProducerThread); t1.start(); // 执行3s后，生产者不再生产 Thread.sleep(3 * 1000); myProducerThread.stopThread(); } } （4）运行结果如下，可以看到整个过程生产者前后一共生产了 6 个元素，并由消费者消费掉：\n","wordCount":"720","inLanguage":"en","datePublished":"2022-04-09T21:27:00+08:00","dateModified":"2022-04-09T21:27:00+08:00","author":{"@type":"Person","name":"zhangyw"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zhangyingwei.github.io/posts/first-page/"},"publisher":{"@type":"Organization","name":"胡说","logo":{"@type":"ImageObject","url":"https://zhangyingwei.github.io/favicon.ico"}}}</script>
</head>
<body class=font-fang-song id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class="header font-fang-song">
<nav class=nav>
<div class=logo>
<a href=https://zhangyingwei.github.io/ accesskey=h title="胡说 (Alt + H)">胡说</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://zhangyingwei.github.io/categories/ title=归档>
<span>归档</span>
</a>
</li>
<li>
<a href=https://zhangyingwei.github.io/tags/ title=标签>
<span>标签</span>
</a>
</li>
<li>
<a href=https://zhangyingwei.github.io/ title>
<span></span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
第一篇文章
</h1>
<div class=post-meta><span title="2022-04-09 21:27:00 +0800 +0800">2022/04/09</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;720 words&nbsp;·&nbsp;zhangyw
</div>
</header>
<div class=post-content><h2 id=一基本介绍>一、基本介绍<a hidden class=anchor aria-hidden=true href=#一基本介绍>#</a></h2>
<h3 id=1什么是-disruptor>1，什么是 Disruptor?<a hidden class=anchor aria-hidden=true href=#1什么是-disruptor>#</a></h3>
<ol>
<li>Disruptor 是英国外汇交易公司 LMAX 开发的一个高性能的并发框架。可以认为是线程间通信的高效低延时的内存消息组件，它最大的特点是高性能。与 Kafka、RabbitMQ 用于服务间的消息队列不同，disruptor 一般用于一个 JVM 中多个线程间消息的传递。</li>
<li>从功能上来看，Disruptor 实现了“队列”的功能，而且是一个有界队列（事实上它是一个无锁的线程间通信库）。作用与 ArrayBlockingQueue 有相似之处，但是disruptor 从功能、性能上又都远好于 ArrayBlockingQueue。</li>
</ol>
<p>实际上这个框架在 log4j，以及 activeMQ 源码扩展中都有使用。(例如：由于采用了 Disruptor，Log4j 2 性能明显优于 Log4j 1.x，Logback 和 java.util.logging，尤其是在多线程应用程序中，异步记录器的吞吐量比 Log4j 1.x 和 Logback 高 18 倍，延迟低。)</p>
<h3 id=2disruptor-的优势>2，Disruptor 的优势<a hidden class=anchor aria-hidden=true href=#2disruptor-的优势>#</a></h3>
<p>（1）Disruptor 最直接的应用场景自然就是“生产者-消费者”模型的应用场合了，虽然这些我们使用 JDK 的 BlockingQueue 也能做到（我之前也写过相关文章：<a href=https://www.hangge.com/blog/cache/detail_2848.html>点击查看</a>），但 Disruptor 的性能比 BlockingQueue 提高了 5~10 倍左右：</p>
<p>下图是官方对 disruptor 和 ArrayBlockingQueue 的性能在不同的应用场景下做了对比，数据中 P 代表 producer，C 代表 consumer，ABS 代表 ArrayBlockingQueue。</p>
<p><img loading=lazy src=assets/images/202004011433085247.png alt>
<br>
（2）也就是说 BlockingQueue 能做的，Disruptor 都能做到且做的更好。同时 Disruptor 还能做得更多：</p>
<ul>
<li>同一个“事件”可以有多个消费者，消费者之间既可以并行处理，也可以相互依赖形成处理的先后次序（形成一个依赖图）；</li>
<li>预分配用于存储事件内容的内存空间；</li>
<li>针对极高的性能目标而实现的极度优化和无锁的设计；</li>
</ul>
<h3 id=3disruptor-性能高效的原因>3，Disruptor 性能高效的原因<a hidden class=anchor aria-hidden=true href=#3disruptor-性能高效的原因>#</a></h3>
<h2 id=二基本用法>二、基本用法<a hidden class=anchor aria-hidden=true href=#二基本用法>#</a></h2>
<h3 id=1添加依赖>1，添加依赖<a hidden class=anchor aria-hidden=true href=#1添加依赖>#</a></h3>
<p>SpringBoot 项目如果要与 Disruptor 进行整合十分简单，只要在 pom 文件中引入 disruptor 依赖即可：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=color:#f92672>&lt;dependency&gt;</span>
    <span style=color:#f92672>&lt;groupId&gt;</span>com.lmax<span style=color:#f92672>&lt;/groupId&gt;</span>
    <span style=color:#f92672>&lt;artifactId&gt;</span>disruptor<span style=color:#f92672>&lt;/artifactId&gt;</span>
    <span style=color:#f92672>&lt;version&gt;</span>3.4.2<span style=color:#f92672>&lt;/version&gt;</span>
<span style=color:#f92672>&lt;/dependency&gt;</span>
</code></pre></div><h3 id=2创建一些工具类>2，创建一些工具类<a hidden class=anchor aria-hidden=true href=#2创建一些工具类>#</a></h3>
<p>我们首先封装一些对于 disruptor 使用的工具类，用于简化开发并约束开发规范。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>/*事件对象*/</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ObjectEvent</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> T obj<span style=color:#f92672>;</span>

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>ObjectEvent</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> T <span style=color:#a6e22e>getObj</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>obj</span><span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setObj</span><span style=color:#f92672>(</span>T obj<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>obj</span> <span style=color:#f92672>=</span> obj<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>（2）需要让 Disruptor 为我们创建事件，我们同时还声明了一个 EventFactory 来实例化 Event 对象：</p>
<p>提示：Disruptor 通过 EventFactory 在 RingBuffer 中预创建 Event 的实例。一个 Event 实例实际上被用作一个“数据槽”，发布者发布前，先从 RingBuffer 获得一个 Event 的实例，然后往 Event 实例中填充数据，之后再发布到 RingBuffer 中，之后由 Consumer 获得该 Event 实例并从中读取数据。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>/*事件生成工厂（用来初始化预分配事件对象）*/</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ObjectEventFactory</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>implements</span> EventFactory<span style=color:#f92672>&lt;</span>ObjectEvent<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>ObjectEventFactory</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> ObjectEvent<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>newInstance</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> ObjectEvent<span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>（3）接着定义一个消费者抽象类，后面我们所有自定义的消费者都需要继承这个抽象类，并实现 consume 方法（对获取的数据进行业务处理）：</p>
<pre tabindex=0><code>/*消费者抽象类*/
public abstract class ADisruptorConsumer&lt;T&gt;
        implements EventHandler&lt;ObjectEvent&lt;T&gt;&gt;, WorkHandler&lt;ObjectEvent&lt;T&gt;&gt; {
    public ADisruptorConsumer() {
    }

    public void onEvent(ObjectEvent&lt;T&gt; event, long sequence, boolean endOfBatch) throws Exception {
        this.onEvent(event);
    }

    public void onEvent(ObjectEvent&lt;T&gt; event) throws Exception {
        this.consume(event.getObj());
    }

    public abstract void consume(T var1);
}
</code></pre><p>（4）接着创建一个 Disruptor 队列操作工具类 DisruptorQueue，用于初始化 disruptor 以及 ringBuffer 对象，并封装类一些常用的方法：</p>
<pre tabindex=0><code>/*Disruptor队列操作工具类*/
public class DisruptorQueue&lt;T&gt; {
    private Disruptor&lt;ObjectEvent&lt;T&gt;&gt; disruptor;
    private RingBuffer&lt;ObjectEvent&lt;T&gt;&gt; ringBuffer;

    public DisruptorQueue(Disruptor&lt;ObjectEvent&lt;T&gt;&gt; disruptor) {
        this.disruptor = disruptor;
        this.ringBuffer = disruptor.getRingBuffer();
        this.disruptor.start();
    }

    public void add(T t) {
        if (t != null) {
            long sequence = this.ringBuffer.next();

            try {
                ObjectEvent&lt;T&gt; event = (ObjectEvent)this.ringBuffer.get(sequence);
                event.setObj(t);
            } finally {
                this.ringBuffer.publish(sequence);
            }
        }
    }

    public void addAll(List&lt;T&gt; ts) {
        if (ts != null) {
            Iterator&lt;T&gt; var2 = ts.iterator();

            while(var2.hasNext()) {
                T t = var2.next();
                if (t != null) {
                    this.add(t);
                }
            }
        }
    }

    public long cursor() {
        return this.disruptor.getRingBuffer().getCursor();
    }

    public void shutdown() {
        this.disruptor.shutdown();
    }

    public Disruptor&lt;ObjectEvent&lt;T&gt;&gt; getDisruptor() {
        return this.disruptor;
    }

    public void setDisruptor(Disruptor&lt;ObjectEvent&lt;T&gt;&gt; disruptor) {
        this.disruptor = disruptor;
    }

    public RingBuffer&lt;ObjectEvent&lt;T&gt;&gt; getRingBuffer() {
        return this.ringBuffer;
    }

    public void setRingBuffer(RingBuffer&lt;ObjectEvent&lt;T&gt;&gt; ringBuffer) {
        this.ringBuffer = ringBuffer;
    }
}
</code></pre><p>（5）最后创建一个 DisruptorQueue 工程类，用于生成上面定义的 DisruptorQueue 对象，并且支持“点对点”以及“发布订阅”这两种模式：</p>
<p>Disruptor 提供了多个 WaitStrategy（等待策略）的实现，每种策略都具有不同性能和优缺点，根据实际运行环境的 CPU 的硬件特点选择恰当的策略，并配合特定的 JVM 的配置参数，能够实现不同的性能提升：</p>
<ul>
<li>BlockingWaitStrategy 是最低效的策略，但其对 CPU 的消耗最小并且在各种不同部署环境中能提供更加一致的性能表现；</li>
<li>SleepingWaitStrategy 的性能表现跟 BlockingWaitStrategy 差不多，对 CPU 的消耗也类似，但其对生产者线程的影响最小，适合用于异步日志类似的场景；</li>
<li>YieldingWaitStrategy 的性能是最好的，适合用于低延迟的系统。在要求极高性能且事件处理线数小于 CPU 逻辑核心数的场景中，推荐使用此策略；例如：CPU 开启超线程的特性。</li>
</ul>
<pre tabindex=0><code>/*Disruptor队列操作工具类工厂*/
public class DisruptorQueueFactory {
    public DisruptorQueueFactory() {
    }

    // 创建&quot;点对电模式&quot;的操作队列，即同一事件会被一组消费者其中之一消费
    public static &lt;T&gt; DisruptorQueue&lt;T&gt; getWorkPoolQueue(int queueSize, boolean isMoreProducer,
                                                         ADisruptorConsumer&lt;T&gt;... consumers) {
        Disruptor&lt;ObjectEvent&lt;T&gt;&gt; _disruptor = new Disruptor(new ObjectEventFactory(),
                queueSize, Executors.defaultThreadFactory(),
                isMoreProducer ? ProducerType.MULTI : ProducerType.SINGLE,
                new SleepingWaitStrategy());
        _disruptor.handleEventsWithWorkerPool(consumers);
        return new DisruptorQueue(_disruptor);
    }

    // 创建&quot;发布订阅模式&quot;的操作队列，即同一事件会被多个消费者并行消费
    public static &lt;T&gt; DisruptorQueue&lt;T&gt; getHandleEventsQueue(int queueSize, boolean isMoreProducer,
                                                             ADisruptorConsumer&lt;T&gt;... consumers) {
        Disruptor&lt;ObjectEvent&lt;T&gt;&gt; _disruptor = new Disruptor(new ObjectEventFactory(),
                queueSize, Executors.defaultThreadFactory(),
                isMoreProducer ? ProducerType.MULTI : ProducerType.SINGLE,
                new SleepingWaitStrategy());
        _disruptor.handleEventsWith(consumers);
        return new DisruptorQueue(_disruptor);
    }

    // 直接通过传入的 Disruptor 对象创建操作队列（如果消费者有依赖关系的话可以用此方法）
    public static &lt;T&gt; DisruptorQueue&lt;T&gt; getQueue(Disruptor&lt;ObjectEvent&lt;T&gt;&gt; disruptor) {
        return new DisruptorQueue(disruptor);
    }
}
</code></pre><h3 id=3使用样例>3，使用样例<a hidden class=anchor aria-hidden=true href=#3使用样例>#</a></h3>
<p>（1）首先我们创建一个生产者，代码如下。我们使用 disruptorQueue 对象的 add() 方法插入元素，当队列未满时，该方法会直接插入没有返回值；队列满时会阻塞等待，一直等到队列未满时再插入。</p>
<pre tabindex=0><code>public class MyProducerThread implements Runnable {
    private String name;
    private DisruptorQueue disruptorQueue;
    private volatile boolean flag = true;
    private static AtomicInteger count = new AtomicInteger();

    public MyProducerThread(String name, DisruptorQueue disruptorQueue) {
        this.name = name;
        this.disruptorQueue = disruptorQueue;
    }

    @Override
    public void run() {
        try {
            System.out.println(now() + this.name + &quot;：线程启动。&quot;);
            while (flag) {
                String data = count.incrementAndGet()+&quot;&quot;;
                // 将数据存入队列中
                disruptorQueue.add(data);
                System.out.println(now() + this.name + &quot;：存入&quot; + data + &quot;到队列中。&quot;);
            }
        } catch (Exception e) {

        } finally {
            System.out.println(now() + this.name + &quot;：退出线程。&quot;);
        }
    }

    public void stopThread() {
        this.flag = false;
    }

    // 获取当前时间（分:秒）
    public String now() {
        Calendar now = Calendar.getInstance();
        return &quot;[&quot; + now.get(Calendar.MINUTE) + &quot;:&quot; + now.get(Calendar.SECOND) + &quot;] &quot;;
    }
}
</code></pre><p>（2）接着创建一个消费者，每次获取到元素之后会等待个 1 秒钟，模拟实际业务处理耗时，也便于观察队列情况。</p>
<pre tabindex=0><code>public class MyConsumer extends ADisruptorConsumer&lt;String&gt; {
    private String name;

    public MyConsumer(String name) {
        this.name = name;
    }

    public void consume(String data) {
        System.out.println(now() + this.name + &quot;：拿到队列中的数据：&quot; + data);
        //等待1秒钟
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    // 获取当前时间（分:秒）
    public String now() {
        Calendar now = Calendar.getInstance();
        return &quot;[&quot; + now.get(Calendar.MINUTE) + &quot;:&quot; + now.get(Calendar.SECOND) + &quot;] &quot;;
    }
}
</code></pre><p>（3）最后分别创建一个生产者以及一个消费者进行测试，并且 3 秒种之后通知生产者线程退出。</p>
<p>注意：RingBuffer 大小（即队列大小）必须是 2 的 N 次方，实际项目中我们通常将其设置为 1024 * 1024。</p>
<pre tabindex=0><code>public class DisruptorTest {
    public static void main(String[] args) throws InterruptedException {

        // 创建一个消费者
        MyConsumer myConsumer = new MyConsumer(&quot;----&gt;消费者1&quot;);

        // 创建一个Disruptor队列操作类对象（RingBuffer大小为4，false表示只有一个生产者）
        DisruptorQueue disruptorQueue = DisruptorQueueFactory.getHandleEventsQueue(4,
                false, myConsumer);

        // 创建一个生产者，开始模拟生产数据
        MyProducerThread myProducerThread = new MyProducerThread(&quot;11111生产者1&quot;, disruptorQueue);
        Thread t1 = new Thread(myProducerThread);
        t1.start();

        // 执行3s后，生产者不再生产
        Thread.sleep(3 * 1000);
        myProducerThread.stopThread();
    }
}
</code></pre><p>（4）运行结果如下，可以看到整个过程生产者前后一共生产了 6 个元素，并由消费者消费掉：</p>
</div>
<footer class=post-footer>
</footer><div id=comment-container></div>
<link rel=stylesheet href=https://unpkg.com/gitalk/dist/gitalk.css>
<script src=https://unpkg.com/gitalk/dist/gitalk.min.js></script>
<script>var gitalk=new Gitalk({clientID:'8655c29fce673368e6e5',clientSecret:'ef357d8004dee38f1c0009780a3e3d6c381b0da4',repo:'zhangyingwei.github.io',owner:'zhangyingwei',admin:['zhangyingwei'],id:location.pathname,distractionFreeMode:!1,language:"zh-CN"});gitalk.render('comment-container')</script>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://zhangyingwei.github.io/>胡说</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>